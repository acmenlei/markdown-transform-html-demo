import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism3 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return clone;
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return clone;
              default:
                return o;
            }
          },
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism3;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism3;
    }
    Prism3.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism3.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism3.languages.markup["entity"];
    Prism3.languages.markup["doctype"].inside["internal-subset"].inside = Prism3.languages.markup;
    Prism3.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addInlined", {
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism3.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism3.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism3.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism3.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang) {
        Prism3.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism3.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism3.languages.html = Prism3.languages.markup;
    Prism3.languages.mathml = Prism3.languages.markup;
    Prism3.languages.svg = Prism3.languages.markup;
    Prism3.languages.xml = Prism3.languages.extend("markup", {});
    Prism3.languages.ssml = Prism3.languages.xml;
    Prism3.languages.atom = Prism3.languages.xml;
    Prism3.languages.rss = Prism3.languages.xml;
    (function(Prism4) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism4.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism4.languages.css["atrule"].inside.rest = Prism4.languages.css;
      var markup = Prism4.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism3);
    Prism3.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism3.languages.javascript = Prism3.languages.extend("clike", {
      "class-name": [
        Prism3.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism3.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism3.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism3.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism3.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism3.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism3.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism3.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism3.languages.markup) {
      Prism3.languages.markup.tag.addInlined("script", "javascript");
      Prism3.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism3.languages.js = Prism3.languages.javascript;
    (function() {
      if (typeof Prism3 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism3.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism3.hooks.add("before-sanity-check", function(env) {
        var pre = env.element;
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism3.util.setLanguage(code, language);
          Prism3.util.setLanguage(pre, language);
          var autoloader = Prism3.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism3.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism3.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism3.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism3.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism3.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseImage.ts
function parseImage(s) {
  let result = "";
  while (matchImage.test(s)) {
    let altStartIdx = s.indexOf("![");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 1);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<p><img alt=${alt} src=${link} /></p>`;
  }
  return result + s;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseSuperLink.ts
function parseSuperLink(s) {
  let result = "";
  while (matchSuperLink.test(s)) {
    let altStartIdx = s.indexOf("[");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 1);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<a href=${link}>${alt}</a>`;
  }
  return result + s;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseText.ts
function parseNormalText(text, inner = false) {
  let result = processStrongText(text);
  result = processObliqueText(result);
  result = parseSingleLineCode(result);
  result = processDeleteText(result);
  result = parseImage(result);
  result = parseSuperLink(result);
  result = parseIcon(result);
  return inner ? result : `<p>${result}</p>`;
}
function processStrongText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("**")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("**");
    if (lastIdx == -1) {
      text = "**" + text;
      break;
    }
    result += `<strong>${text.slice(0, lastIdx)}</strong>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function processObliqueText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("*")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("*");
    if (lastIdx == -1) {
      text = "*" + text;
      break;
    }
    result += `<i>${text.slice(0, lastIdx)}</i>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function processDeleteText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("~~")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("~~");
    if (lastIdx == -1) {
      text = "~~" + text;
      break;
    }
    result += `<del>${text.slice(0, lastIdx)}</del>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function parseSingleLineCode(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("`")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("`");
    if (lastIdx == -1) {
      text = "`" + text;
      break;
    }
    result += `<code class=single-code>${text.slice(0, lastIdx)}</code>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function parseIcon(text) {
  return text.replace(/icon:(\w+)(\s|\b)/g, ($, $1) => {
    return `<i class='iconfont icon-${$1}'></i>`;
  });
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/utils/index.ts
var matchTitle = /(#+)\s(.*)/g;
var matchOrderList = /^\s*(\d)\./;
var matchSuperLink = /\[(.*)\]\((.*)\)/;
var matchImage = /!\[(.*)\]\((.*)\)/;
function processForamt(list) {
  if (/^\s+/.test(list[0])) {
    list[0] = list[0].replace(/^(\s+)/g, ($1) => "\n");
  }
  if (!list[0].startsWith("\n")) {
    list[0] = "\n" + list[0];
  }
}
function genTemplateStringOfNodes(nodes, isOrder) {
  let listString = "";
  for (let node of nodes) {
    let childrenString = node.children.length ? genTemplateStringOfNodes(node.children, isOrder) : "";
    listString += `<li>${parseNormalText(
      node.value + childrenString,
      true
    )}</li>`;
  }
  return `<${isOrder ? "ol" : "ul"}>${listString}</${isOrder ? "ol" : "ul"}>`;
}
function isOrderList(s) {
  return matchOrderList.test(s);
}
function isNoOrderList(s) {
  let idx = s.indexOf("-");
  return idx == 0 || idx != -1 && !s.slice(0, idx).trim();
}
function isTitle(s) {
  return s.indexOf("#") != -1;
}
function isPreCode(s) {
  return s.startsWith("```");
}
function isBLock(s) {
  return s.startsWith("> ");
}
function isHorizontalLine(s) {
  return s.trim() === "---";
}
function isTable(s) {
  return s.trim()[0] === "|";
}
function native(s) {
  return s.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function isMultColumnStart(s) {
  return s.trim().startsWith("::: start");
}
function isMultColumnEnd(s) {
  return s.trim().startsWith("::: end");
}
function isMultColumn(s) {
  return s.trim().startsWith(":::");
}
function isHeadLayoutStart(s) {
  return s.trim().startsWith("::: headStart");
}
function isHeadLayoutEnd(s) {
  return s.trim().startsWith("::: headEnd");
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseBlock.ts
function parseBlock(text) {
  return `<blockquote>${text.slice(2)}</blockquote>`;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseCode.ts
var import_prismjs = __toESM(require_prism(), 1);
import "/Library/coderlei-pro/coderlei-pro-example/vue-pro/md-parser-demo/node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/themes/prism-tomorrow.min.css";
import "/Library/coderlei-pro/coderlei-pro-example/vue-pro/md-parser-demo/node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css";

// node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.js
!function() {
  if ("undefined" != typeof Prism && "undefined" != typeof document) {
    var e = "line-numbers", n = /\n(?!$)/g, t = Prism.plugins.lineNumbers = { getLine: function(n2, t2) {
      if ("PRE" === n2.tagName && n2.classList.contains(e)) {
        var i2 = n2.querySelector(".line-numbers-rows");
        if (i2) {
          var r2 = parseInt(n2.getAttribute("data-start"), 10) || 1, s = r2 + (i2.children.length - 1);
          t2 < r2 && (t2 = r2), t2 > s && (t2 = s);
          var l = t2 - r2;
          return i2.children[l];
        }
      }
    }, resize: function(e2) {
      r([e2]);
    }, assumeViewportIndependence: true }, i = void 0;
    window.addEventListener("resize", function() {
      t.assumeViewportIndependence && i === window.innerWidth || (i = window.innerWidth, r(Array.prototype.slice.call(document.querySelectorAll("pre.line-numbers"))));
    }), Prism.hooks.add("complete", function(t2) {
      if (t2.code) {
        var i2 = t2.element, s = i2.parentNode;
        if (s && /pre/i.test(s.nodeName) && !i2.querySelector(".line-numbers-rows") && Prism.util.isActive(i2, e)) {
          i2.classList.remove(e), s.classList.add(e);
          var l, o = t2.code.match(n), a = o ? o.length + 1 : 1, u = new Array(a + 1).join("<span></span>");
          (l = document.createElement("span")).setAttribute("aria-hidden", "true"), l.className = "line-numbers-rows", l.innerHTML = u, s.hasAttribute("data-start") && (s.style.counterReset = "linenumber " + (parseInt(s.getAttribute("data-start"), 10) - 1)), t2.element.appendChild(l), r([s]), Prism.hooks.run("line-numbers", t2);
        }
      }
    }), Prism.hooks.add("line-numbers", function(e2) {
      e2.plugins = e2.plugins || {}, e2.plugins.lineNumbers = true;
    });
  }
  function r(e2) {
    if (0 != (e2 = e2.filter(function(e3) {
      var n2, t3 = (n2 = e3, n2 ? window.getComputedStyle ? getComputedStyle(n2) : n2.currentStyle || null : null)["white-space"];
      return "pre-wrap" === t3 || "pre-line" === t3;
    })).length) {
      var t2 = e2.map(function(e3) {
        var t3 = e3.querySelector("code"), i2 = e3.querySelector(".line-numbers-rows");
        if (t3 && i2) {
          var r2 = e3.querySelector(".line-numbers-sizer"), s = t3.textContent.split(n);
          r2 || ((r2 = document.createElement("span")).className = "line-numbers-sizer", t3.appendChild(r2)), r2.innerHTML = "0", r2.style.display = "block";
          var l = r2.getBoundingClientRect().height;
          return r2.innerHTML = "", { element: e3, lines: s, lineHeights: [], oneLinerHeight: l, sizer: r2 };
        }
      }).filter(Boolean);
      t2.forEach(function(e3) {
        var n2 = e3.sizer, t3 = e3.lines, i2 = e3.lineHeights, r2 = e3.oneLinerHeight;
        i2[t3.length - 1] = void 0, t3.forEach(function(e4, t4) {
          if (e4 && e4.length > 1) {
            var s = n2.appendChild(document.createElement("span"));
            s.style.display = "block", s.textContent = e4;
          } else
            i2[t4] = r2;
        });
      }), t2.forEach(function(e3) {
        for (var n2 = e3.sizer, t3 = e3.lineHeights, i2 = 0, r2 = 0; r2 < t3.length; r2++)
          void 0 === t3[r2] && (t3[r2] = n2.children[i2++].getBoundingClientRect().height);
      }), t2.forEach(function(e3) {
        var n2 = e3.sizer, t3 = e3.element.querySelector(".line-numbers-rows");
        n2.style.display = "none", n2.innerHTML = "", e3.lineHeights.forEach(function(e4, n3) {
          t3.children[n3].style.height = e4 + "px";
        });
      });
    }
  }
}();

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseCode.ts
function parseCode(templates, i, templateLength, options) {
  let result = "", language = templates[i].slice(3).trim().toLowerCase();
  ++i;
  while (i < templateLength && !templates[i].startsWith("```")) {
    result += templates[i] + "\n";
    i++;
  }
  templates[i] = "";
  const highlight = options.highlight ? `language-${language}` : "", lineNumber = options.lineNumber ? "line-numbers" : "", classes = [highlight, lineNumber].join(" ");
  result = `<pre><code ${classes && `class='${classes}'`}>${import_prismjs.default.highlight(
    result,
    import_prismjs.default.languages[language],
    language
  )}</code></pre>`;
  return { startIdx: i, result };
}
var reHighlight = import_prismjs.default.highlightAll;

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseNoOrderList.ts
function parseNoOrderList(templates, i, templateLength) {
  let result = "";
  for (; i < templateLength; i++) {
    if (!templates[i].trim()) {
      continue;
    }
    if (templates[i].trim()[0] === "-" && templates[i].indexOf("-") != -1) {
      result += templates[i] + "\n";
    } else {
      break;
    }
  }
  result = processNoOrderList(result);
  return { startIdx: i, result };
}
function processNoOrderList(template) {
  const list = template.match(/(\s?)+-\s(.*)/g);
  if (!list) {
    return template;
  }
  processForamt(list);
  const nodes = genListHelper(list);
  const root = genTemplateStringOfNodes(nodes, false);
  return root;
}
function genListHelper(list) {
  const results = [], currentOperStack = [], n = list.length;
  for (let i = 0; i < n; i++) {
    const level = list[i].indexOf("-");
    const listItem = { children: [], value: list[i].slice(level + 1), level, parent: null };
    if (!currentOperStack.length) {
      results.push(listItem);
      currentOperStack.push(listItem);
      continue;
    }
    const topLevel = currentOperStack[currentOperStack.length - 1].level;
    const curLevel = list[i].indexOf("-");
    let parent;
    if (topLevel === curLevel) {
      parent = currentOperStack[currentOperStack.length - 1].parent;
    } else {
      if (topLevel > curLevel) {
        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {
          currentOperStack.pop();
        }
        parent = currentOperStack[currentOperStack.length - 1].parent;
      } else {
        parent = currentOperStack[currentOperStack.length - 1];
      }
    }
    listItem.parent = parent;
    parent ? parent.children.push(listItem) : results.push(listItem);
    currentOperStack.push(listItem);
  }
  return results;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseOrderList.ts
function parseOrderList(templates, i, templateLength) {
  let result = "";
  for (; i < templateLength; i++) {
    if (!templates[i].trim()) {
      continue;
    }
    if (matchOrderList.test(templates[i])) {
      result += templates[i] + "\n";
    } else {
      break;
    }
  }
  result = processOrderList(result);
  return { startIdx: i, result };
}
function processOrderList(template) {
  const list = template.match(/\s*\d\.(.*)/g);
  if (!list) {
    return template;
  }
  processForamt(list);
  const nodes = genListHelper2(list);
  const root = genTemplateStringOfNodes(nodes, true);
  return root;
}
function genListHelper2(list) {
  const results = [], currentOperStack = [], n = list.length;
  for (let i = 0; i < n; i++) {
    let level = 0;
    if (matchOrderList.test(list[i])) {
      level = list[i].indexOf(String(RegExp.$1 + "."));
    }
    const listItem = { children: [], value: list[i].slice(level + 2), level, parent: null };
    if (!currentOperStack.length) {
      results.push(listItem);
      currentOperStack.push(listItem);
      continue;
    }
    const topLevel = currentOperStack[currentOperStack.length - 1].level;
    const curLevel = level;
    let parent;
    if (topLevel === curLevel) {
      parent = currentOperStack[currentOperStack.length - 1].parent;
    } else {
      if (topLevel > curLevel) {
        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {
          currentOperStack.pop();
        }
        parent = currentOperStack[currentOperStack.length - 1].parent;
      } else {
        parent = currentOperStack[currentOperStack.length - 1];
      }
    }
    listItem.parent = parent;
    parent ? parent.children.push(listItem) : results.push(listItem);
    currentOperStack.push(listItem);
  }
  return results;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseHorLine.ts
function parseHorizontalLine(text) {
  if (text.length !== 3) {
    return text;
  }
  return text === "---" ? `<hr/>` : text;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseTitle.ts
function getTitleLevel(level) {
  return level.length > 6 ? 6 : level.length;
}
function parseTitle(s) {
  return s.trim().replace(matchTitle, ($1, $2, $3) => {
    return `<h${getTitleLevel($2)}>${parseNormalText($3, true)}</h${getTitleLevel($2)}>`;
  });
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseTable.ts
function parseTable(templates, i, templateLength) {
  let result = "<table>";
  result += processTableTHead(templates[i]);
  result += `<tbody >`;
  ++i;
  for (; i < templateLength; i++) {
    if (templates[i].trim()[0] === "|") {
      result += processTabletBody(templates[i]);
    } else {
      break;
    }
  }
  result += `</tbody></table>`;
  return { startIdx: i - 1, result };
}
function processTableTHead(s) {
  let preIdx = -1, template = "<thead><tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        template += `<th>${s.slice(preIdx + 1, i)}</th>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr></thead>`;
}
function processTabletBody(s) {
  let preIdx = -1, template = "<tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        let cnts = s.slice(preIdx + 1, i);
        if (cnts.trim()[0] === "-") {
          continue;
        }
        template += `<td>${cnts}</td>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr>`;
}
function isValidedSplitChar(s, i) {
  return s[i] === " " || s[i] == void 0;
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseHeadLayout.ts
function parseHeadLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=head-layout>`;
  ++i;
  while (i < templateLength && !isHeadLayoutEnd(templates[i])) {
    if (isMultColumnStart(templates[i])) {
      const { startIdx, result } = parseLayout(templates, i, templateLength, options);
      resultStr += result;
      i = startIdx + 1;
    } else {
      resultStr += templates[i].trim() ? markdownToHTML(templates[i], { ...options, xss: false }) : "";
      i++;
    }
  }
  resultStr += "</div>";
  return { result: resultStr, startIdx: i };
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseLayout.ts
function parseLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=flex-layout>`, tmpS = "";
  ++i;
  while (i < templateLength && !isMultColumnEnd(templates[i])) {
    if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isMultColumn(templates[i])) {
      resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
      tmpS = "";
    } else {
      tmpS += templates[i].trim() ? "\n" + templates[i] + "\n" : "";
    }
    i++;
  }
  resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
  resultStr += `</div>`;
  return { result: resultStr, startIdx: i };
}

// node_modules/.pnpm/markdown-transform-html@1.6.0_prismjs@1.29.0/node_modules/markdown-transform-html/lib/core/parseToHTML.ts
var defaultOptions = {
  lineNumber: false,
  highlight: false,
  xss: true
};
function markdownToHTML(template, options) {
  let op = options || defaultOptions, templateStr = "";
  op = Object.assign({ ...defaultOptions }, op);
  let templates = op.xss ? native(template).split("\n") : template.split("\n"), len = (templates == null ? void 0 : templates.length) || 0;
  for (let i = 0; i < len; ) {
    if (isTitle(templates[i])) {
      templateStr += parseTitle(templates[i]);
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isHorizontalLine(templates[i])) {
      templateStr += parseHorizontalLine(templates[i]);
      ++i;
    } else if (isTable(templates[i])) {
      const { result, startIdx } = parseTable(templates, i, len);
      i = startIdx;
      templateStr += result;
    } else if (isNoOrderList(templates[i])) {
      const { result, startIdx } = parseNoOrderList(templates, i, len);
      i = startIdx - 1;
      templateStr += result;
    } else if (isOrderList(templates[i])) {
      const { result, startIdx } = parseOrderList(templates, i, len);
      i = startIdx - 1;
      templateStr += result;
    } else if (isPreCode(templates[i])) {
      const { result, startIdx } = parseCode(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isBLock(templates[i])) {
      templateStr += parseBlock(templates[i]);
    } else {
      if (templates[i] = templates[i].trim()) {
        templateStr += parseNormalText(templates[i]);
      }
    }
    i++;
  }
  return templateStr;
}
export {
  markdownToHTML,
  reHighlight
};
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
//# sourceMappingURL=markdown-transform-html.js.map
