// node_modules/markdown-transform-html/lib/core/parseImage.ts
function parseImage(s) {
  let result = "";
  while (matchImage.test(s)) {
    let altStartIdx = s.indexOf("![");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 1);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<p><img alt=${alt} src=${link} /></p>`;
  }
  return result + s;
}

// node_modules/markdown-transform-html/lib/core/parseSuperLink.ts
function parseSuperLink(s) {
  let result = "";
  while (matchSuperLink.test(s)) {
    let altStartIdx = s.indexOf("[");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 1);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<a href=${link}>${alt}</a>`;
  }
  return result + s;
}

// node_modules/markdown-transform-html/lib/core/parseText.ts
function parseNormalText(text, inner = false) {
  let result = processStrongText(text);
  result = processObliqueText(result);
  result = processStrongText2(result);
  result = processObliqueText2(result);
  result = parseSingleLineCode(result);
  result = processDeleteText(result);
  result = parseImage(result);
  result = parseSuperLink(result);
  result = parseIcon(result);
  return inner ? result : `<p>${result}</p>`;
}
function processStrongText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("**")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("**");
    result += `<strong>${text.slice(0, lastIdx)}</strong>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function processStrongText2(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("__")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("__");
    result += `<strong>${text.slice(0, lastIdx)}</strong>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function processObliqueText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("*")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("*");
    result += `<i>${text.slice(0, lastIdx)}</i>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function processObliqueText2(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("_")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("_");
    result += `<i>${text.slice(0, lastIdx)}</i>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function processDeleteText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("~~")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("~~");
    result += `<del>${text.slice(0, lastIdx)}</del>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function parseSingleLineCode(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("`")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("`");
    result += `<code class=single-code>${text.slice(0, lastIdx)}</code>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function parseIcon(text) {
  return text.replace(/icon:(\w+)(\s|\b)/g, ($, $1) => {
    return `<i class='iconfont icon-${$1}'></i>`;
  });
}

// node_modules/markdown-transform-html/utils/index.ts
var matchTitle = /(#+)\s(.*)/g;
var matchOrderList = /^\s*(\d)\./;
var matchSuperLink = /\[(.*)\]\((.*)\)/;
var matchImage = /!\[(.*)\]\((.*)\)/;
var matchSpecComments = /\/\*(.*)\*\//g;
var matchFunction = /(function)([\s\(&lt])/g;
function processForamt(list) {
  if (/^\s+/.test(list[0])) {
    list[0] = list[0].replace(/^(\s+)/g, ($1) => "\n");
  }
  if (!list[0].startsWith("\n")) {
    list[0] = "\n" + list[0];
  }
}
function genTemplateStringOfNodes(nodes, isOrder) {
  let listString = "";
  for (let node of nodes) {
    let childrenString = node.children.length ? genTemplateStringOfNodes(node.children, isOrder) : "";
    listString += `<li>${parseNormalText(node.value + childrenString, true)}</li>`;
  }
  return `<${isOrder ? "ol" : "ul"}>${listString}</${isOrder ? "ol" : "ul"}>`;
}
function isOrderList(s) {
  return matchOrderList.test(s);
}
function isNoOrderList(s) {
  let idx = s.indexOf("-");
  return idx == 0 || idx != -1 && !s.slice(0, idx).trim();
}
function isTitle(s) {
  return s.indexOf("#") != -1;
}
function isPreCode(s) {
  return s.startsWith("```");
}
function isBLock(s) {
  return s.startsWith("> ");
}
function isNeedEndChar(i, n, ch) {
  return i < n - 1 ? ch : "";
}
function isComments(s) {
  return s.startsWith("//") || s.startsWith("/*") || s.startsWith("*") || s.startsWith("#");
}
function isHorizontalLine(s) {
  return s.trim() === "---";
}
function isTable(s) {
  return s.trim()[0] === "|";
}
function isSpecLineComments(s) {
  return matchSpecComments.test(s);
}
function isFuntionKeyWord(s) {
  return matchFunction.test(s);
}
function parseString(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf('"')) != -1 || (idx = text.indexOf("'")) != -1) {
    let even = false;
    text.indexOf('"') != -1 ? even = true : {};
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = even ? text.indexOf('"') : text.indexOf("'");
    result += `<q class=declare-string>${text.slice(0, lastIdx)}</q>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function parseBoolean(s) {
  return s.replace(/([^\w])(false|true)(?!\w)/g, ($, $1, $2) => `${$1}<span class=declare-boolean>${$2}</span>`);
}
function parseNumber(s) {
  return s.replace(/([^\w])(\d+)(?![\w\.])/g, ($, $1, $2) => `${$1}<span class=declare-number>${$2}</span>`);
}
function parseNull(s) {
  return s.replace(/(\s*null)(?!\w)/g, ($, $1) => `<span class=declare-operator-char>${$1}</span>`);
}
function native(s) {
  return s.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function lineNumber(line, need) {
  return need ? `<span class=line-number>${line}</span>` : "";
}
function isMultColumnStart(s) {
  return s.trim().startsWith("::: start");
}
function isMultColumnEnd(s) {
  return s.trim().startsWith("::: end");
}
function isMultColumn(s) {
  return s.trim().startsWith(":::");
}
function isHeadLayoutStart(s) {
  return s.trim().startsWith("::: headStart");
}
function isHeadLayoutEnd(s) {
  return s.trim().startsWith("::: headEnd");
}

// node_modules/markdown-transform-html/lib/core/parseBlock.ts
function parseBlock(text) {
  return `<blockquote>${text.slice(2)}</blockquote>`;
}

// node_modules/markdown-transform-html/lib/languages/js/index.ts
function parseJSSyntax(content, line, options) {
  let template = "";
  let s = content.split("\n");
  for (let i = 0; i < s.length; i++) {
    let sub = s[i];
    template += analysisOfGrammar(native(sub), line++, options);
  }
  return template;
}
function analysisOfGrammar(s, line, options) {
  let st = [], tmpStr = "", l = 0, res = "";
  s = parseString(s);
  let n = s.length;
  for (let i = 0; i < n; i++) {
    if (s[i] == ")") {
      let cur = "";
      while (st.length && (cur = st.pop()) != "(") {
        tmpStr = cur + tmpStr;
      }
      if (cur != "(") {
        st.push(processParcel(tmpStr + ")", false));
      } else {
        l--;
        st.push(processParcel(tmpStr, true));
      }
      tmpStr = "";
    } else {
      s[i] == "(" && l++;
      st.push(s[i]);
    }
  }
  let last = 0;
  while (l--) {
    last = st.lastIndexOf("(");
    res = "(" + processParcel(st.slice(last + 1).join(""), false) + res;
    st = st.slice(0, last);
  }
  if (st.length) {
    res = processParcel(st.join(""), false) + res;
  }
  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`;
}
function processParcel(inner, parcel) {
  if (!inner.trim()) {
    return parcel ? `(${inner})` : inner;
  }
  if (isComments(inner.trim())) {
    return parseSingleComments(inner);
  }
  let result = inner;
  result = parseSpecComents(result);
  result = parseString(result);
  result = parseParcelData(result);
  result = parseOperatorChar(result);
  result = parseArrowFunction(result);
  result = parseFuntionExecute(result);
  result = parseFuntion(result);
  result = parseBoolean(result);
  result = parseNumber(result);
  result = parseNull(result);
  return parcel ? `(${result})` : result;
}
function parseParcelData(content) {
  if (/^(const|int|string|var|let)/.test(content.trim())) {
    if (/(\w+\s+)(.*\s*)=(.*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)=(.*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant($1)}${parserSubContent($2)}=${parseParcelData($3)}`;
      });
    }
    if (/(\w+\s+)(.*\s*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant($1)}${parserSubContent($2)}`;
      });
    }
  }
  let result = "";
  let datas = content.split(",");
  for (let i = 0, n = datas.length; i < n; i++) {
    result += `${parserSubContent(datas[i])}${isNeedEndChar(i, n, ",")}`;
  }
  return result;
}
function parserSubContent(s) {
  if (/(\s*\w+\s*)?:(\s*\w+\s*)/.test(s)) {
    return s.replace(/(\s*\w+\s*)?:(\s*\w+\s*)/, ($, $1, $2) => {
      if (!$1) {
        return `:<span class=declare-param-type>${$2}</span>`;
      }
      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`;
    });
  }
  if (isFuntionKeyWord(s)) {
    return parseFuntion(s);
  }
  return s;
}
function parseFuntion(s) {
  return s.replace(matchFunction, ($, $1, $2) => {
    return `<span class=declare-function>${$1}</span>${$2}`;
  });
}
function parseArrowFunction(content) {
  if (!content.includes("=>")) {
    return content;
  }
  return content.replace(/=>/g, ($) => `<span class=declare-arrow-func>${$}</span>`);
}
function parseFuntionExecute(content) {
  return content.replace(/(\w+)(\s*)\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);
}
function parseDeclareConstant(text) {
  return text.replace(/(const|let|var)(\s+)/gi, ($, $1, $2) => {
    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`;
  });
}
function parseOperatorChar(text) {
  if (isSpecLineComments(text)) {
    return parseSpecComents(text);
  }
  return text.replace(/(class|await|in|of|typeof|module|async|this|as|super|module|export\s+default|export|import|from|while|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\s+\(\.])/g, ($, $1) => {
    return `<span class=declare-operator-char>${$1}</span>`;
  });
}
function parseSingleComments(text) {
  return `<span class=declare-comments>${text}</span>`;
}
function parseSpecComents(text) {
  return text.replace(matchSpecComments, ($) => {
    return `<span class=declare-comments>${$}</span>`;
  });
}

// node_modules/markdown-transform-html/lib/languages/html/index.ts
function parseHTMLSyntax(syntax, line, options) {
  syntax = syntax.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  if (/(<!--.*-->)/g.test(syntax)) {
    return `${genPrefixer(line, options)}${genComment(RegExp.$1)}</p>`;
  } else if (/(\s*)<(\!?\w+)(.*)>(.*)<\/\w+>/g.test(syntax)) {
    let attrs = RegExp.$3.trim().split(" "), result = processAttrs(attrs);
    return `${genPrefixer(line, options)}${RegExp.$1}&lt${genHTMLTag(RegExp.$2)}${result && "&nbsp;" + result}&gt${RegExp.$4}&lt/${genHTMLTag(RegExp.$2)}&gt</p>`;
  } else if (/(\s*)<(\!?\w+)(.*)>(.*)/g.test(syntax)) {
    let attrs = RegExp.$3.trim().split(" "), result = processAttrs(attrs);
    return `${genPrefixer(line, options)}${RegExp.$1}&lt${genHTMLTag(RegExp.$2)}${result && "&nbsp;" + result}&gt${RegExp.$4}</p>`;
  } else if (/(.*)(\s*)<\/(\w+)>/g.test(syntax)) {
    return `${genPrefixer(line, options)}${RegExp.$2}${RegExp.$1}&lt/${genHTMLTag(RegExp.$2)}&gt</p>`;
  } else {
    return parseJSSyntax(syntax, line++, options);
  }
}
function genHTMLTag(tag) {
  return `<span class=declare-html-tag>${tag}</span>`;
}
function genComment(cnt) {
  return `<span class=declare-comments>${native(cnt)}</span>`;
}
function genPrefixer(line, options) {
  return `<p class=line-code>${lineNumber(line, options.lineNumber)}`;
}
function processAttrs(attrs) {
  let result = "";
  for (let i = 0, n = attrs.length; i < n; i++) {
    let attr = attrs[i];
    if (!attr.trim()) {
      result += attr;
      continue;
    }
    let splitIdx = attr.indexOf("=");
    if (splitIdx != -1) {
      let key = attr.slice(0, splitIdx), value = attr.slice(splitIdx + 1);
      result += `<span class=declare-attr-key>${key}</span>=<span class=declare-attr-value>${value}</span>${isNeedEndChar(i, n, "&nbsp;")}`;
    } else {
      result += attr;
      continue;
    }
  }
  return result;
}

// node_modules/markdown-transform-html/lib/languages/c/index.ts
function parseCSyntax() {
  return "";
}

// node_modules/markdown-transform-html/lib/languages/java/index.ts
function parseJavaSyntax(content, line, options) {
  let template = "";
  let s = content.split("\n");
  for (let i = 0; i < s.length; i++) {
    let sub = s[i];
    template += analysisOfGrammar2(sub, line++, options);
  }
  return template;
}
function analysisOfGrammar2(s, line, options) {
  let st = [], tmpStr = "", l = 0, res = "";
  for (let i = 0; i < s.length; i++) {
    if (s[i] == ")") {
      let cur = "";
      while (st.length && (cur = st.pop()) != "(") {
        tmpStr = cur + tmpStr;
      }
      if (cur != "(") {
        st.push(processParcel2(tmpStr + ")", false));
      } else {
        l--;
        st.push(processParcel2(tmpStr, true));
      }
      tmpStr = "";
    } else {
      s[i] == "(" && l++;
      st.push(s[i]);
    }
  }
  let last = 0;
  while (l--) {
    last = st.lastIndexOf("(");
    res = "(" + processParcel2(st.slice(last + 1).join(""), false) + res;
    st = st.slice(0, last);
  }
  if (st.length) {
    res = processParcel2(st.join(""), false) + res;
  }
  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`;
}
function processParcel2(inner, parcel) {
  if (!inner.trim()) {
    return parcel ? `(${inner})` : inner;
  }
  if (isComments(inner.trim())) {
    return parseSingleComments2(inner);
  }
  let result = inner;
  result = parseSpecComents2(result);
  result = parseParcelData2(result);
  result = parseOperatorChar2(result);
  result = parseString(result);
  result = parseFuntionExecute2(result);
  result = parseBoolean(result);
  result = parseNumber(result);
  result = parseNull(result);
  return parcel ? `(${result})` : result;
}
function parseParcelData2(content) {
  if (/^(char|int|String|Byte\[?\]?|[A-Z]+)/.test(content.trim())) {
    if (/(\w+\s+)(.*\s*)=(.*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)=(.*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant2($1)}${parserSubContent2($2)}=${parseParcelData2($3)}`;
      });
    }
    if (/(\w+\s+)(.*\s*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant2($1)}${parserSubContent2($2)}`;
      });
    }
  }
  let result = "";
  let datas = content.split(",");
  for (let i = 0, n = datas.length; i < n; i++) {
    result += `${parserSubContent2(datas[i])}${isNeedEndChar(i, n, ",")}`;
  }
  return result;
}
var matchNormalType = /(\s*\w+\s*)?:(\s*\w+\s*)/g;
var matchGenericType = /(:\s*\w+\s*)?&lt;(\s*\/?\s*\w+\s*)&gt;/g;
function parserSubContent2(s) {
  if (matchGenericType.test(s)) {
    return s.replace(matchGenericType, ($, $1, $2) => {
      let rest = $1 ? `<span class=declare-param-type>${$1}</span>` : "";
      return `${rest}&lt;<span class=declare-param-type>${$2}</span>&gt;`;
    });
  }
  if (matchNormalType.test(s)) {
    return s.replace(matchNormalType, ($, $1, $2) => {
      if (!$1) {
        return `:<span class=declare-param-type>${$2}</span>`;
      }
      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`;
    });
  }
  return s;
}
function parseFuntionExecute2(content) {
  return content.replace(/(\w+)(\s*)\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);
}
function parseDeclareConstant2(text) {
  return text.replace(/(const|let|var|int|string|Byte\[?\]?|[A-Z]+)(\s+)/gi, ($, $1, $2) => {
    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`;
  });
}
function parseOperatorChar2(text) {
  if (isSpecLineComments(text)) {
    return parseSpecComents2(text);
  }
  return text.replace(/(class|in|of|this|super|interface|module|import|from|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\s\(\.])/g, ($, $1) => {
    return `<span class=declare-operator-char>${$1}</span>`;
  });
}
function parseSingleComments2(text) {
  return `<span class=declare-comments>${text}</span>`;
}
function parseSpecComents2(text) {
  return text.replace(matchSpecComments, ($) => {
    return `<span class=declare-comments>${$}</span>`;
  });
}

// node_modules/markdown-transform-html/lib/languages/ts/index.ts
function parseTSSyntax(content, line, options) {
  let template = "";
  let s = content.split("\n");
  for (let i = 0; i < s.length; i++) {
    let sub = s[i];
    template += analysisOfGrammar3(native(sub), line++, options);
  }
  return template;
}
function analysisOfGrammar3(s, line, options) {
  let st = [], tmpStr = "", l = 0, res = "";
  for (let i = 0; i < s.length; i++) {
    if (s[i] == ")") {
      let cur = "";
      while (st.length && (cur = st.pop()) != "(") {
        tmpStr = cur + tmpStr;
      }
      if (cur != "(") {
        st.push(processParcel3(tmpStr + ")", false));
      } else {
        l--;
        st.push(processParcel3(tmpStr, true));
      }
      tmpStr = "";
    } else {
      s[i] == "(" && l++;
      st.push(s[i]);
    }
  }
  let last = 0;
  while (l--) {
    last = st.lastIndexOf("(");
    res = "(" + processParcel3(st.slice(last + 1).join(""), false) + res;
    st = st.slice(0, last);
  }
  if (st.length) {
    res = processParcel3(st.join(""), false) + res;
  }
  return `<p>${lineNumber(line, options.lineNumber)}<span>${res}</span></p>`;
}
function processParcel3(inner, parcel) {
  if (!inner.trim()) {
    return parcel ? `(${inner})` : inner;
  }
  if (isComments(inner.trim())) {
    return parseSingleComments3(inner);
  }
  let result = inner;
  result = parseSpecComents3(result);
  result = parseParcelData3(result);
  result = parseOperatorChar3(result);
  result = parseString(result);
  result = parseArrowFunction2(result);
  result = parseFuntionExecute3(result);
  result = parseFuntion2(result);
  result = parseBoolean(result);
  result = parseNumber(result);
  result = parseNull(result);
  return parcel ? `(${result})` : result;
}
function parseParcelData3(content) {
  if (/^(const|int|string|var|let)/.test(content.trim())) {
    if (/(\w+\s+)(.*\s*)=(.*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)=(.*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant3($1)}${parserSubContent3($2)}=${parseParcelData3($3)}`;
      });
    }
    if (/(\w+\s+)(.*\s*)/.test(content)) {
      return content.replace(/(\s*\w+\s+)(.*\s*)/, ($, $1, $2, $3) => {
        return `${parseDeclareConstant3($1)}${parserSubContent3($2)}`;
      });
    }
  }
  let result = "";
  let datas = content.split(",");
  for (let i = 0, n = datas.length; i < n; i++) {
    result += `${parserSubContent3(datas[i])}${isNeedEndChar(i, n, ",")}`;
  }
  return result;
}
var matchNormalType2 = /(\s*\w+\s*)?:(\s*\w+\s*)/g;
var matchGenericType2 = /(:\s*\w+\s*)?&lt;(\s*\/?\s*\w+\s*)&gt;/g;
function parserSubContent3(s) {
  if (matchGenericType2.test(s)) {
    return s.replace(matchGenericType2, ($, $1, $2) => {
      let rest = $1 ? `<span class=declare-param-type>${$1}</span>` : "";
      return `${rest}&lt;<span class=declare-param-type>${$2}</span>&gt;`;
    });
  }
  if (matchNormalType2.test(s)) {
    return s.replace(matchNormalType2, ($, $1, $2) => {
      if (!$1) {
        return `:<span class=declare-param-type>${$2}</span>`;
      }
      return `<span class=declare-param>${$1}</span>:<span class=declare-param-type>${$2}</span>`;
    });
  }
  if (isFuntionKeyWord(s)) {
    return parseFuntion2(s);
  }
  return s;
}
function parseFuntion2(s) {
  return s.replace(matchFunction, ($, $1, $2) => {
    return `<span class=declare-function>${$1}</span>${$2}`;
  });
}
function parseArrowFunction2(content) {
  if (!content.includes("=>")) {
    return content;
  }
  return content.replace(/=>/g, ($) => `<span class=declare-arrow-func>${$}</span>`);
}
function parseFuntionExecute3(content) {
  return content.replace(/(\w+)(\s*)\(/g, ($, $1, $2) => `<span class=declare-func-execute>${$1}</span>${$2}(`);
}
function parseDeclareConstant3(text) {
  return text.replace(/(const|let|var|int|string)(\s+)/gi, ($, $1, $2) => {
    return `<span class=declare-keyword>${$1}</span><span class=declare-constant-name>${$2}</span>`;
  });
}
function parseOperatorChar3(text) {
  if (isSpecLineComments(text)) {
    return parseSpecComents3(text);
  }
  return text.replace(/(class|in|of|this|super|interface|typeof|module|declare|type|keyof|infer|export\s+default|export|import|from|extends|new|abstract|void|static|return|break|continue|switch|case|finally|try|catch|else|if|throw)(?=[\s\(\.])/g, ($, $1) => {
    return `<span class=declare-operator-char>${$1}</span>`;
  });
}
function parseSingleComments3(text) {
  return `<span class=declare-comments>${text}</span>`;
}
function parseSpecComents3(text) {
  return text.replace(matchSpecComments, ($) => {
    return `<span class=declare-comments>${$}</span>`;
  });
}

// node_modules/markdown-transform-html/lib/languages/index.ts
var languages = {
  ["java"]: parseJavaSyntax,
  ["c"]: parseCSyntax,
  ["c++"]: parseCSyntax,
  ["c#"]: parseCSyntax,
  ["js"]: parseJSSyntax,
  ["javascript"]: parseJSSyntax,
  ["ts"]: parseTSSyntax,
  ["typescript"]: parseTSSyntax,
  ["html"]: parseHTMLSyntax
};
var languages_default = languages;

// node_modules/markdown-transform-html/lib/core/parseCode.ts
function parseCode(templates, i, templateLength, options) {
  let result = "", language = templates[i].slice(3).trim().toLowerCase(), line = 1;
  ++i;
  while (i < templateLength && !templates[i].startsWith("```")) {
    result += options.highlight ? languages_default[language](templates[i], line++, options) : templates[i] + "\n";
    i++;
  }
  templates[i] = "";
  return { startIdx: i, result: !options.highlight ? `<pre><code>${result}</code></pre>` : `<pre><span class=language>${language}</span><code>${result}</code></pre>` };
}

// node_modules/markdown-transform-html/lib/core/parseNoOrderList.ts
function parseNoOrderList(templates, i, templateLength) {
  let result = "";
  for (; i < templateLength; i++) {
    if (!templates[i].trim()) {
      continue;
    }
    if (templates[i].trim()[0] === "-" && templates[i].indexOf("-") != -1) {
      result += templates[i] + "\n";
    } else {
      break;
    }
  }
  result = processNoOrderList(result);
  return { startIdx: i, result };
}
function processNoOrderList(template) {
  const list = template.match(/(\s?)+-\s(.*)/g);
  if (!list) {
    return template;
  }
  processForamt(list);
  const nodes = genListHelper(list);
  const root = genTemplateStringOfNodes(nodes, false);
  return root;
}
function genListHelper(list) {
  const results = [], currentOperStack = [], n = list.length;
  for (let i = 0; i < n; i++) {
    const level = list[i].indexOf("-");
    const listItem = { children: [], value: list[i].slice(level + 1), level, parent: null };
    if (!currentOperStack.length) {
      results.push(listItem);
      currentOperStack.push(listItem);
      continue;
    }
    const topLevel = currentOperStack[currentOperStack.length - 1].level;
    const curLevel = list[i].indexOf("-");
    let parent;
    if (topLevel === curLevel) {
      parent = currentOperStack[currentOperStack.length - 1].parent;
    } else {
      if (topLevel > curLevel) {
        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {
          currentOperStack.pop();
        }
        parent = currentOperStack[currentOperStack.length - 1].parent;
      } else {
        parent = currentOperStack[currentOperStack.length - 1];
      }
    }
    listItem.parent = parent;
    parent ? parent.children.push(listItem) : results.push(listItem);
    currentOperStack.push(listItem);
  }
  return results;
}

// node_modules/markdown-transform-html/lib/core/parseOrderList.ts
function parseOrderList(templates, i, templateLength) {
  let result = "";
  for (; i < templateLength; i++) {
    if (!templates[i].trim()) {
      continue;
    }
    if (matchOrderList.test(templates[i])) {
      result += templates[i] + "\n";
    } else {
      break;
    }
  }
  result = processOrderList(result);
  return { startIdx: i, result };
}
function processOrderList(template) {
  const list = template.match(/\s*\d\.(.*)/g);
  if (!list) {
    return template;
  }
  processForamt(list);
  const nodes = genListHelper2(list);
  const root = genTemplateStringOfNodes(nodes, true);
  return root;
}
function genListHelper2(list) {
  const results = [], currentOperStack = [], n = list.length;
  for (let i = 0; i < n; i++) {
    let level = 0;
    if (matchOrderList.test(list[i])) {
      level = list[i].indexOf(String(RegExp.$1 + "."));
    }
    const listItem = { children: [], value: list[i].slice(level + 2), level, parent: null };
    if (!currentOperStack.length) {
      results.push(listItem);
      currentOperStack.push(listItem);
      continue;
    }
    const topLevel = currentOperStack[currentOperStack.length - 1].level;
    const curLevel = level;
    let parent;
    if (topLevel === curLevel) {
      parent = currentOperStack[currentOperStack.length - 1].parent;
    } else {
      if (topLevel > curLevel) {
        while (currentOperStack[currentOperStack.length - 1].level > curLevel) {
          currentOperStack.pop();
        }
        parent = currentOperStack[currentOperStack.length - 1].parent;
      } else {
        parent = currentOperStack[currentOperStack.length - 1];
      }
    }
    listItem.parent = parent;
    parent ? parent.children.push(listItem) : results.push(listItem);
    currentOperStack.push(listItem);
  }
  return results;
}

// node_modules/markdown-transform-html/lib/core/parseHorLine.ts
function parseHorizontalLine(text) {
  if (text.length !== 3) {
    return text;
  }
  return text === "---" ? `<hr/>` : text;
}

// node_modules/markdown-transform-html/lib/core/parseTitle.ts
function getTitleLevel(level) {
  return level.length > 6 ? 6 : level.length;
}
function parseTitle(s) {
  return s.trim().replace(matchTitle, ($1, $2, $3) => {
    return `<h${getTitleLevel($2)}>${parseNormalText($3, true)}</h${getTitleLevel($2)}>`;
  });
}

// node_modules/markdown-transform-html/lib/core/parseTable.ts
function parseTable(templates, i, templateLength) {
  let result = "<table>";
  result += processTableTHead(templates[i]);
  result += `<tbody >`;
  ++i;
  for (; i < templateLength; i++) {
    if (templates[i].trim()[0] === "|") {
      result += processTabletBody(templates[i]);
    } else {
      break;
    }
  }
  result += `</tbody></table>`;
  return { startIdx: i - 1, result };
}
function processTableTHead(s) {
  let preIdx = -1, template = "<thead><tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        template += `<th>${s.slice(preIdx + 1, i)}</th>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr></thead>`;
}
function processTabletBody(s) {
  let preIdx = -1, template = "<tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        let cnts = s.slice(preIdx + 1, i);
        if (cnts.trim()[0] === "-") {
          continue;
        }
        template += `<td>${cnts}</td>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr>`;
}
function isValidedSplitChar(s, i) {
  return s[i] === " " || s[i] == void 0;
}

// node_modules/markdown-transform-html/lib/core/parseHeadLayout.ts
function parseHeadLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=head-layout>`;
  ++i;
  while (i < templateLength && !isHeadLayoutEnd(templates[i])) {
    if (isMultColumnStart(templates[i])) {
      const { startIdx, result } = parseLayout(templates, i, templateLength, options);
      resultStr += result;
      i = startIdx + 1;
    } else {
      resultStr += templates[i].trim() ? markdownToHTML(templates[i], { ...options, xss: false }) : "";
      i++;
    }
  }
  resultStr += "</div>";
  return { result: resultStr, startIdx: i };
}

// node_modules/markdown-transform-html/lib/core/parseLayout.ts
function parseLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=flex-layout>`, tmpS = "";
  ++i;
  while (i < templateLength && !isMultColumnEnd(templates[i])) {
    if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isMultColumn(templates[i])) {
      resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
      tmpS = "";
    } else {
      tmpS += templates[i].trim() ? "\n" + templates[i] + "\n" : "";
    }
    i++;
  }
  resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
  resultStr += `</div>`;
  return { result: resultStr, startIdx: i };
}

// node_modules/markdown-transform-html/lib/core/parseToHTML.ts
var defaultOptions = {
  lineNumber: false,
  highlight: false,
  xss: true
};
function markdownToHTML(template, options) {
  let op = options || defaultOptions, templateStr = "";
  op = Object.assign({ ...defaultOptions }, op);
  let templates = op.xss ? native(template).split("\n") : template.split("\n"), len = (templates == null ? void 0 : templates.length) || 0;
  for (let i = 0; i < len; ) {
    if (isTitle(templates[i])) {
      templateStr += parseTitle(templates[i]);
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isHorizontalLine(templates[i])) {
      templateStr += parseHorizontalLine(templates[i]);
      ++i;
    } else if (isTable(templates[i])) {
      const { result, startIdx } = parseTable(templates, i, len);
      i = startIdx;
      templateStr += result;
    } else if (isNoOrderList(templates[i])) {
      const { result, startIdx } = parseNoOrderList(templates, i, len);
      i = startIdx - 1;
      templateStr += result;
    } else if (isOrderList(templates[i])) {
      const { result, startIdx } = parseOrderList(templates, i, len);
      i = startIdx - 1;
      templateStr += result;
    } else if (isPreCode(templates[i])) {
      const { result, startIdx } = parseCode(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isBLock(templates[i])) {
      templateStr += parseBlock(templates[i]);
    } else {
      if (templates[i] = templates[i].trim()) {
        templateStr += parseNormalText(templates[i]);
      }
    }
    i++;
  }
  return templateStr;
}
export {
  markdownToHTML
};
//# sourceMappingURL=markdown-transform-html.js.map
